# 3장. 함수

공통된 로직을 빼내 함수로 추출하고 변수명을 변경하는 것만으로 프로그램 내부를 직관적으로 파악할 수 있을 만큼 읽기 쉬운 코드로 완성될 수 있다. 그렇다면 함수에 어떤 속성을 부여해서 추출해야지만, 읽는 사람으로부터 직관적이다는 느낌을 받을 수 있을까?

<br>

**1.  작게 만들어라**
첫번째는 함수를 작게 만드는 것이다. 클린코드에서는 정말정말 짧은 길이의 함수를 만들고, 그 의미를 명백하게 만들 것을 강조하고 있다.
```kotlin
fun renderPageWithSetupsAndTeardowns(
    pageData: PageData,
    isSuite: Boolean
) {
    if(isTestPage(pageData)) 
      includeSetupAndTeardownPages(pageData, isSuite)
    return pageData.getHtml()
}
```

해당 함수는 단 3줄만으로 행위를 다 담아내고 있다. 내부에 있는 함수가 이야기 하나를 표현하고있고, 그 의도가 너무 명백하다. 
다시 말해서 if/else & white 문에 들어가는 블록은 한줄이어야 한다.
그렇다면 바깥을 감싸고 있는 함수가 작아질 뿐만 아니라, 이해하기도 쉬워진다. 이 의미는 곧 중첩구조가 생길만큼 함수가 커져서는 안된다는 뜻이기도 하다.

<br>

**2. 한 가지만 해라**
제일 중요하다. 함수는 한 가지만 해야한다. 그 한가지를 잘해야 한다. 하지만 언급하고 있는 "한가지" 가 무엇을 의미하는지는 알기 어렵다. 

<br>

**3. 함수 당 추상화 수준은 하나로**
함수가 확실히 "한 가지" 작업만 하려면 함수의 모든 문장의 추상화 수준이 동일해야 한다. 책에서는 메소드에 따라 추상화 수준이 어떤지 정의하고 있다.
``` kotlin
getHtml() {} // 추상화 수준이 매우 높음
val pagePathName = PathParser.render(pagepath) // 추상화 수준이 중간
buffer.append("\n") // 추상화 수준이 낮음
```
`getHtml()` 은 html을 가져올 수 있는 코드이다. 어떠한 인자 없이 실행되고 있으며, 그 내부는 다양한 로직과, 또다른 메소드를 통해 파싱이 이루어지고 있을 테지만 우리는 해당 메소드를 통해 어떻게 진행되고있는지 모른다. **"html 만 얻어와"** 만 알 뿐이다. 그리고 이 메소드는 다른 곳에서도 범용적으로 사용할 수 있다. 그래서 추상화 수준이 높다고 정의한다.

`PathParser.render(pagePath)` 는 페이지 경로를 파싱해서 렌더링해주는 함수이다. pagePath 를 인자로 넣어주어야 실행될 수 있는 메소드이다. pagePath 값이 아닌 pageName, pageExtension 을 넣으려면 원하는 대로 작동하지 않을 것이다.  이처럼, 특정 범위(pagePath 범위 내)에서 사용할 수 있는 메소드들을 추상화 수준이 중간이라고 표현한다.

`append("\n")` 과 같은 경우는 추상화 수준이 아주 낮다. 우선 하드코딩되어있는 문자열이 사용할 수 있는 메소드의 범위를 매우 축소시켜주고 사용처 또한 제한적이기 때문이다.

만약 한 함수내에 다양한 추상화 수준이 들어간다면, 읽는 사람으로 하여금 헷갈리게 만들 수 있다. 특정 표현이 근본 개념인지 세부사항인지 구분하기 어렵기 때문이다. 절대 근본 개념과 세부사항을 뒤섞지 말아라.

 - 위에서 아래로 코드 읽기: **내려가기** 규칙
코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 위에서 아래로 내려갈수록 추상화 수준이 한 단계씩 낮아진다. 책에서는 아래와 같은 예시를 들고 있다.


👉 1) TO **설정 페이지(2)**와 해제 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지를 포함하고, 해제 페이지를 포함한다.
👉 2) TO 설정 페이지를 포함하려면, 슈트이면 **슈트 설정 페이지를 포함(3)**한 후 일반 설정 페이지를 포함한다.
👉 3) TO 슈트 설정 페이지를 포함하려면, **부모 계층에서 "suiteSetUp" 페이지를 찾아(4)** include 문과 페이지 경로를 추가한다.
👉 4) TO 부모 계층을 검색하려면, ....

코드를 내려가면서 현재 추상화 수준을 설명하면서 그 수준을 일관되게 유지해야한다. 
<br>

**4. 서술적인 이름을 사용해라**
함수가 하는 일을 잘 표현하기 위해 서술적인 이름을 사용해라. 길고 서술적인 이름은 길고 서술적인 주석, 어렵고 짧은 이름보다 훨씬 좋다. 
<br>

**5. 함수 인수**
이상적인 함수의 인수는 0개이다. 인수는 함수의 개념을 이해하기 어렵게 만든다.  함수의 이름과 인수의 갯수의 차이에 따라 추상화 수준이 달라지게된다. 코드를 읽는 사람에게 `includeSetupPageInfo(PageContent())` 보다 `includeSetupPageInfo()`가 더 이해하기 쉬울 것이다.

테스트 관점에서도 동일하다. 여러 인수 조합으로 구성된 함수는 검증하기 위한 테스트코드가 복잡해질 것이다. 최선은 입력인수가 없는 경우이며, 차선은 입력인수가 1개인 경우이다.

함수에 1개의 인자를 넘기는 가장 큰 경우는 두가지이다. 첫번째는 **인수에게 질문을 던지는 경우**, 두번째는 **인수를 무언가로 변환해 결과로 반환하는 경우**이다.
``` kotlin
fun fileExists(fileName: String): Boolean // 첫번째 케이스
fun fileOpen(fileName: String): InputStream // 두번째 케이스
```

이 경우가 아니라면 단항함수는 가급적 피하는 것이 좋다. 

플래그 인수는 함수가 한번에 여러가지의 일을 한다는 것을 암시하기 때문에, 절대로 지양해야한다.

인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 하지만 point(x, y) 와 같이 인수가 2개여도 자연스럽게 읽히는 관계에 대해서는 사용해도 좋다. 

인수가 3개인 함수는 신중이 사용하라고 한다. 예시로, `assertEquals(msg, expected, actual)` 이라는 함수가 존재하게 될때 코드를 읽는 사람은 매번 함수를 볼 때마다 주춤하다가 msg 를 무시해야한다는 사실을 상기할 것이다. 인자가 3개인 함수는 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다.

함수의 의도나 인수의 순서와 의도를 제대로 표현하려면, 함수와 인수가 동사/명사 쌍을 이루는 것이 좋다. 예를들어 `assertEquals` 보다 `assertExpectedEqualsActual` 처럼 말이다. 그렇다면 인수 순서를 기억할 필요가 없어진다.

<br>

**6. 부수효과를 일으키지 마라**
함수에서 한 가지 일만 하기로 약속하고선 다른 일을 해서는 안된다. 한 함수에서 부수효과가 나타난다는 것은 거짓말을 하고있음과 같은 이야기이다.

<br>

**7. 명령과 조회를 분리해라**
함수는 무엇인가를 수행하거나 답하거나 둘 중 하나만 담당해야한다. 
``` kotlin
fun set(attribute: String, value: String) Boolean

if (set("username", "unclebob")) { }
```
set 함수는 이름이 attribute인 속성을 찾아 value로 설정한 후 성공하면 true, 실패하면 false를 반환한다. 그렇다면 코드를 읽는 사람에게는 if 문을 어떻게 해석할까? username 이 unclebob으로 설정되어있는지 확인하는 코드인가? username 을 unclebob으로 설정하는 코드인가? 해석하기가 어려워진다. 코드만 봐서는 의미가 모호하기 때문이다.
``` kotlin
if (attributeExists("username")) { 
  setAttribute("username", "unclebob")
}
```
이 문제를 해결하기 위해서는 명령과 조회를 분리해 혼란을 제거하는 것이다. 