이 장에서는 여러 스레드를 동시에 돌리는 이유, 그에 따른 어려움과 해결 방법, 테스트 방법과 문제점에 대해 이야기한다.

## 동시성이 필요한 이유?

동시성은 결합(Coupling)을 없애는 전략 : 무엇, 언제를 분리
-> 프로그램을 거대한 루프 하나가 아닌 작은 협력 프로그램 여럿으로 볼 수 있다.

ex)
- 서블릿 : 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.
- 정보 수집기 : 수집하면서 계속 새로운 정보가 쌓이므로 소요되는 시간이 늘어난다.
- 많은 사용자를 동시에 처리하여 응답 시간 높이기
- 정보 대량 분석 : 정보를 나눠 여러 컴퓨터에서 돌려서 응답 시간 높이기

### 미신과 오해

- 동시성은 항상 성능을 높여준다.
대기 시간이 아주 길거나 독립적인 계산이 충분히 많은 경우에만 해당 -> 일상적이지 않다.

- 동시성을 구현해도 설계는 변하지 않는다.
무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.

- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
컨테이너 동작 방식, 동시 수정, 데드락을 어떻게 처리해야 할지 알아야 한다.

### 타당한 생각

- 동시성은 다소 부하를 유발한다.
- 복잡
- 동시성 버그 재현은 어렵다.
- 동시성을 구현하려면 근본적인 설계 전략을 재고해야 한다.

## 난관

두 스레드가 같은 변수를 참조했을 때 잘못된 결과를 내놓을 수 있다.
그 경우의 수는 두 스레드가 자바 코드 한 줄을 거쳐가는 경로의 수만큼 : 12870개

## 동시성 방어 원칙

#### 단일 책임 원칙 (SRP)
오브젝트를 변경할 이유가 하나여야 한다. 동시성 코드와 다른 코드를 분리해라.
동시성 코드는 독자적인 개발, 변경, 조율 주기가 있으며 독자적인 난관이 있기 때문이다.

#### 따름 정리 : 자료 범위를 제한하라
공유 객체를 사용하는 코드 내 임계 영역을 ```synchronized``` 키워드로 보호하라.
하지만 이런 임계 영역을 수정할 일이 많아질 수록 임계 영역을 빼먹기도 하고 올바로 보호했는지 확인하는 노력을 들여야 하므로 최대한 공유 자료를 줄여라 : **캡슐화**

#### 따름 정리 : 자료 사본을 사용하라
처음부터 공유를 하지 않는다. 객체를 복사해 읽기 전용으로 사용한다.
복사 비용 = 사본 생성 + 가비지 컬렉션 < 내부 잠금

#### 따름 정리 : 스레는 가능한 독립적으로 구현하라
다른 스레드와 자료를 공유하지 않는다. 각 스레드는 클라이언트 요청 하나를 처리하며 정보는 비공유 출처에서 가져오고 로컬 변수에 저장한다. -> 동기화 필요 없음

## 라이브러리를 이해하라
- 스레드 환경에 안전한 컬렉션 사용
    - java.util.concurrent 패키지
    - ReentrantLock, Semaphore, CountDownLatch

- 서로 무관한 작업 수행할 때는 executor 프레임 워크 사용
- 가능하다면 스레드가 차단(blocking)되지 않는 방법 사용
- 일부 클래스 라이브러리는 스레드에 안전하지 못함

## 실행 모델을 이해하라
다음은 실행 모델 설명을 위한 기본 영어들이다.
- 한정된 자원 : 다중 스레드 환경에서 사용하는 자원.
	- ex. DB 연결, 길이가 제한된 읽기/쓰기 버퍼
- 상호 배제 : 한번에 한 스레드만 공유 자료/자원 사용 가능
- 기아 : 스레드가 영원히 자원을 기다린다.
- 데드락 : 스레드들이 서로 끝나기를 기다린다.
- 라이브락 : 락을 거는 단계에서 스레드들이 서로 방해

#### 생상자-소비자
생산자 스레드 : 정보 생성. 버퍼나 대기열에 넣음
소비자 스레드 : 대기열에서 정보를 가져와 사용
서로에게 시그널을 보냄 -> 둘 다 진행 가능하지만 서로에게서 시그널 기다릴 가능성 존재

#### 읽기-쓰기
읽기 스레드 : 공유 자원 사용
쓰기 스레드 : 공유 자원 갱신
-> 처리율(Throughput)이 중요
처리율을 강조하면 기아 현상 / 갱신을 허용하면 처리율에 영향

#### 식사하는 철학자들
![](https://images.velog.io/images/s2moon98/post/459c5f58-f7da-4741-ba74-eb29eba094c7/image.png)

동시에 모두 왼쪽 들면 평생 오른쪽 들 수 없음
여러 프로세스가 자원을 얻으려 경쟁 -> 데드락, 라이브락, 처리율 저하, 효율성 저하

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
메서드 사이 의존성이 존재하면 찾아내기 어려운 동시성 버그 발생
-> 공유 객체 하나에는 메서드 하나만 사용하라

메서드를 여러개 사용해야 할 때 :
- 클라이언트에서 잠금
- 서버에서 잠금
- 연결 서버 : 잠금을 수행하는 중단 단계 생성. 서버에서 잠금과 유사하지만 서버 변경하지 x

## 동기화하는 부분을 작게 만들어라
synchronized 를 이용해서 락을 설정할 수 있지만 이는 스레드를 지연시키고 부하를 가중시킨다. 임계 영역의 개수를 줄이기 위해서 임계 영역의 크기를 틀리는 것도 마찬가지

## 올바른 종료 코드는 구현하기 어렵다
종료 코드는 처음부터 고민하여 구현해야 한다.
ex.
부모 스레드가 자식 스레드를 여러개 만든 후 종료를 기다리다가 자식 스레드가 데드락에 걸린 경우
자식 스레드 두개가 생산자-소비자 관계에서 생산자는 종료했지만 소비자가 시그널을 기다리는 경우

## 스레드 코드 테스트하기
문제를 노출하는 테스트 케이스 작성 -> 프로그램 설정, 시스템 설정, 부하를 바꿔가며 자주 돌리며 한번 통과했다고 넘어가면 안된다.

#### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
시스템 실패를 일회성으로 치부하지 마라

#### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 분리하자

#### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
스레드 수 바꿔보기, 실제 환경/테스트 환경에서 실행하기, 다양한 속도로 돌려보기, 반복 테스트하기

#### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
스레드 개수를 조율하기 쉽게 코드 구현
프로그램 중간에도 스레드 개수를 변경하는 방법 고려
처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민

#### 프로세서 수보다 많은 스레드를 돌려보라
스와핑을 고려하려면 프로세서 수보다 많은 스레드를 돌린다.

#### 다른 플랫폼에서 돌려보라
플랫폼마다 스레드를 처리하는 정책이 다르다.

#### 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
실패하는 경로가 실행될 확률은 매우 저조하다. 이렇게 드물게 발생하는 오류를 더 자주 일으키려면 보조 코드를 추가해 코드가 실행되는 순서를 바꿔준다.
- 직접 구현

```java
public synchronized String nextUrlOrNull() {
	if (hasNext()) {
    	String utl = urlGenerator.next();
        Thread.yield();		// 테스트를 위해 추가
        updateHasNext();
        return url;
    }
    return null;
}
```

하지만 이 방법엔 문제점이 있다.
보조 코드의 위치 선정, 함수 호출 위치 선정, 배포 코드에 보조 코드 그대로 남겨둘 경우 성능 저하, 무작위적
-> 테스트 환경에서 보조 코드를 실행해야 하며 실행할 때마다 설정을 바꿔줘야 한다.

- 자동화
AOF, CGLIB, ASM 등과 같은 도구 사용

```java
public class ThreadJigglePoint {
	public static void jiggle() {
        // 배포할 땐 비워두고 테스트할 땐 무작위로 sleep이나 yield 호출
    }
}

public synchronized StringnextUrlOrNull() {
	if (hasNext()) {
    	ThreadJigglePoint.jiggle();
        String url = urlGenerator.next();
        ThreadJigglePoint.jiggle();
        updateHasNext();
        ThreadJigglePoint.jiggle();
        return url;
    }
    return null;
}
```

jiggle : 스레드를 매번 다른 순서로 실행하기 위해서 코드를 흔든다.
